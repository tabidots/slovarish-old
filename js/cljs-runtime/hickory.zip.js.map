{"version":3,"sources":["hickory/zip.cljc"],"mappings":";AAOA;;;;0BAAA,1BAAMA,4DAGHC;AAHH,AAIE,OAACC,mBAAW,AAACC,qBAAWC,yBACZ,2DAAA,3DAACC,6CAAKC,wEACN,WAAKC,KAAKC;AAAV,AACE,0DAAA,nDAACC,8CAAMF,8DAAc,iBAAAG,oBAAKF;AAAL,AAAA,oBAAAE;AAAc,OAACC,8CAAMC,iBAAOJ;;AAA5BE;;;GACvBT;;AAUd;;;uBAAA,vBAAOY,sDAEJN;AAFH,AAGE,GAAI,AAACO,wBAAQP;AAEX,GAAI,AAACQ,qBAAK,AAACC,iBAAOT;AAChB,OAACD,cAAI,oDAAA,pDAACW,+CAAOV;;AACb,OAACD,cAAI,oDAAA,pDAACW,+CAAOV;;;AAEfA;;;AAKJ;;;;mBAAA,nBAAOW,8CAGJX,KAAKC;AAHR,AAME,GAAI,AAACM,wBAAQP;AACX,GAAI,AAACQ,qBAAK,AAACC,iBAAOT;AAChB,OAACY,6CAAK,oDAAA,IAAA,xDAACF,+CAAOV,cAAUC;;AACxB,OAACG,8CAAMC,iBAAO,AAACQ,gBAAMb,MAAMC;;;AAC7BA;;;AAGJ;;;yBAAA,zBAAMa,0DAEHpB;AAFH,AAGE,OAACC,mBAAWoB,4BACAT,qBACAK,iBACAjB","names":["hickory.zip/hickory-zip","root","clojure.zip/zipper","cljs.core/complement","cljs.core/string?","cljs.core.comp","cljs.core/seq","node","children","cljs.core.assoc","and__4251__auto__","cljs.core.apply","cljs.core/vector","hickory.zip/children","cljs.core/vector?","cljs.core/map?","cljs.core/second","cljs.core.subvec","hickory.zip/make","cljs.core.into","cljs.core/first","hickory.zip/hiccup-zip","cljs.core/sequential?"],"sourcesContent":["(ns hickory.zip\n  (:require [clojure.zip :as zip]))\n\n;;\n;; Hickory\n;;\n\n(defn hickory-zip\n  \"Returns a zipper for html dom maps (as from as-hickory),\n  given a root element.\"\n  [root]\n  (zip/zipper (complement string?)\n              (comp seq :content)\n              (fn [node children]\n                (assoc node :content (and children (apply vector children))))\n              root))\n\n;;\n;; Hiccup\n;;\n\n;; Just to make things easier, we go ahead and do the work here to\n;; make hiccup zippers work on both normalized (all items have tag,\n;; attrs map, and any children) and unnormalized hiccup forms.\n\n(defn- children\n  \"Takes a hiccup node (normalized or not) and returns its children nodes.\"\n  [node]\n  (if (vector? node)\n    ;; It's a hiccup node vector.\n    (if (map? (second node)) ;; There is an attr map in second slot.\n      (seq (subvec node 2))  ;; So skip tag and attr vec.\n      (seq (subvec node 1))) ;; Otherwise, just skip tag.\n    ;; Otherwise, must have a been a node list\n    node))\n\n;; Note, it's not made clear at all in the docs for clojure.zip, but as far as\n;; I can tell, you are given a node potentially with existing children and\n;; the sequence of children that should totally replace the existing children.\n(defn- make\n  \"Takes a hiccup node (normalized or not) and a sequence of children nodes,\n   and returns a new node that has the the children argument as its children.\"\n  [node children]\n  ;; The node might be either a vector (hiccup form) or a seq (which is like a\n  ;; node-list).\n  (if (vector? node)\n    (if (map? (second node))                 ;; Again, check for normalized vec.\n      (into (subvec node 0 2) children)      ;; Attach children after tag&attrs.\n      (apply vector (first node) children))  ;; Otherwise, attach after tag.\n    children))   ;; We were given a list for node, so just return the new list.\n\n\n(defn hiccup-zip\n  \"Returns a zipper for Hiccup forms, given a root form.\"\n  [root]\n  (zip/zipper sequential?\n              children\n              make\n              root))\n"]}