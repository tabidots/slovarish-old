{"version":3,"sources":["hickory/select.cljc"],"mappings":"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","names":["hickory.select/until","f","val","pred","next-val","hickory.select/count-until","cnt","hickory.select/next-pred","hzip-loc","p1__34175#","clojure.zip/next","or__4253__auto__","clojure.zip/end?","hickory.select/prev-pred","p1__34176#","clojure.zip/prev","hickory.select/left-pred","p1__34177#","clojure.zip/left","hickory.select/right-pred","p1__34178#","clojure.zip/right","hickory.select/up-pred","p1__34179#","clojure.zip/up","hickory.select/next-of-node-type","node-type","p1__34180#","cljs.core._EQ_","clojure.zip/node","hickory.select/prev-of-node-type","p1__34181#","hickory.select/left-of-node-type","p1__34182#","hickory.select/right-of-node-type","p1__34183#","hickory.select/after-subtree","zip-loc","curr-loc","var_args","G__34185","hickory.select/select-next-loc","js/Error","selector-fn","hickory.select.select_next_loc","next-fn","end?-fn","loc","hickory.select/select-locs","hickory-tree","hickory.zip/hickory-zip","selected-nodes","cljs.core/transient","cljs.core/persistent!","cljs.core.conj_BANG_","hickory.select/select","cljs.core.mapv","hickory.select/node-type","type","node","and__4251__auto__","clojure.string/lower-case","cljs.core/name","hickory.select/tag","tag","node-tag","G__34187","hickory.select/attr","attr-name","hickory.select.attr","_","predicate","attr-key","cljs.core.keyword","cljs.core/contains?","G__34188","cljs.core.get_in","hickory.select/id","id","p1__34189#","hickory.select/class","class-name","class-str","cljs.core.into","clojure.string.split","p1__34190#","parse-classes","hickory.select/any","hickory.select/element","hickory.select/element-child","possible-parent","hickory.select/root","hickory.select/find-in-text","re","p1__34191#","cljs.core/some","cljs.core/re-find","cljs.core.filter","cljs.core/string?","hickory.select/n-moves-until","n","c","move","term-pred","distance","cljs.core/rem","G__34194","hickory.select/nth-of-type","typ","hickory.select.nth_of_type","sel","p1__34192#","x","cljs.core/nil?","G__34197","hickory.select/nth-last-of-type","hickory.select.nth_last_of_type","p1__34195#","G__34200","hickory.select/nth-child","hickory.select.nth_child","p1__34198#","G__34203","hickory.select/nth-last-child","hickory.select.nth_last_child","p1__34201#","hickory.select/first-child","fexpr__34204","hickory.select/last-child","fexpr__34205","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","hickory.select/and","seq34207","self__4852__auto__","cljs.core/seq","selectors","p1__34206#","cljs.core/every?","hickory.select/or","seq34209","p1__34208#","hickory.select/not","selector","cljs.core/not","hickory.select/el-not","hickory.select.and","hickory.select/ordered-adjacent","seq34210","G__34211","cljs.core/first","cljs.core/next","self__4851__auto__","move-fn","cljs.core.into_array","cljs.core/IFn","idx","cljs.core/count","temp__5751__auto__","next-loc","fexpr__34212","cljs.core.nth","hickory.select/child","seq34213","cljs.core.apply","cljs.core/reverse","hickory.select/follow-adjacent","seq34215","p1__34214#","hickory.select/precede-adjacent","seq34217","p1__34216#","hickory.select/ordered","seq34218","G__34219","fst-selector","fexpr__34221","hickory.select/descendant","seq34222","hickory.select/follow","seq34224","p1__34223#","hickory.select/precede","seq34226","p1__34225#","hickory.select/has-descendant","subtree-start-loc","clojure.zip/down","has-children?","cljs.core.not_EQ_","subtree-end-loc","p1__34227#","hickory.select/has-child","p1__34228#"],"sourcesContent":["(ns hickory.select\n  \"Functions to query hickory-format HTML data.\n\n   See clojure.zip for more information on zippers, locs, nodes, next, etc.\"\n  (:require [clojure.zip :as zip]\n            [clojure.string :as string]\n            [hickory.zip :as hzip])\n  #?(:clj\n     (:import clojure.lang.IFn))\n  (:refer-clojure :exclude [and or not class]))\n\n;;\n;; Utilities\n;;\n\n(defn until\n  \"Calls f on val until pred called on the result is true. If not, it\n   repeats by calling f on the result, etc. The value that made pred\n   return true is returned.\"\n  [f val pred]\n  (let [next-val (f val)]\n    (if (pred next-val)\n      next-val\n      (recur f next-val pred))))\n\n(defn count-until\n  \"Calls f on val until pred called on the result is true. If not, it\n   repeats by calling f on the result, etc. The count of times this\n   process was repeated until pred returned true is returned.\"\n  [f val pred]\n  (loop [next-val val\n         cnt 0]\n    (if (pred next-val)\n      cnt\n      (recur (f next-val) (inc cnt)))))\n\n(defn next-pred\n  \"Like clojure.zip/next, but moves until it reaches a node that returns\n   true when the function in the pred argument is called on them, or reaches\n   the end.\"\n  [hzip-loc pred]\n  (until zip/next hzip-loc #(clojure.core/or (zip/end? %)\n                                             (pred %))))\n\n(defn prev-pred\n  \"Like clojure.zip/prev, but moves until it reaches a node that returns\n   true when the function in the pred argument is called on them, or reaches\n   the beginning.\"\n  [hzip-loc pred]\n  (until zip/prev hzip-loc #(clojure.core/or (nil? %)\n                                             (pred %))))\n\n(defn left-pred\n  \"Like clojure.zip/left, but moves until it reaches a node that returns\n   true when the function in the pred argument is called on them, or reaches\n   the left boundary of the current group of siblings.\"\n  [hzip-loc pred]\n  (until zip/left hzip-loc #(clojure.core/or (nil? %)\n                                             (pred %))))\n\n(defn right-pred\n  \"Like clojure.zip/right, but moves until it reaches a node that returns\n   true when the function in the pred argument is called on them, or reaches\n   the right boundary of the current group of siblings.\"\n  [hzip-loc pred]\n  (until zip/right hzip-loc #(clojure.core/or (nil? %)\n                                              (pred %))))\n\n(defn up-pred\n  \"Like clojure.zip/up, but moves until it reaches a node that returns\n   true when the function in the pred argument is called on them, or reaches\n   the beginning.\"\n  [hzip-loc pred]\n  (until zip/up hzip-loc #(clojure.core/or (nil? %)\n                                           (pred %))))\n\n(defn next-of-node-type\n  \"Like clojure.zip/next, but only counts moves to nodes that have\n   the given type.\"\n  [hzip-loc node-type]\n  (next-pred hzip-loc #(= node-type (:type (zip/node %)))))\n\n(defn prev-of-node-type\n  \"Like clojure.zip/prev, but only counts moves to nodes that have\n   the given type.\"\n  [hzip-loc node-type]\n  (prev-pred hzip-loc #(= node-type (:type (zip/node %)))))\n\n(defn left-of-node-type\n  \"Like clojure.zip/left, but only counts moves to nodes that have\n   the given type.\"\n  [hzip-loc node-type]\n  (left-pred hzip-loc #(= node-type (:type (zip/node %)))))\n\n(defn right-of-node-type\n  \"Like clojure.zip/right, but only counts moves to nodes that have\n   the given type.\"\n  [hzip-loc node-type]\n  (right-pred hzip-loc #(= node-type (:type (zip/node %)))))\n\n(defn after-subtree\n  \"Given a zipper loc, returns the zipper loc that is the first one after\n   the arg's subtree, if there is a subtree. If there is no loc after this\n   loc's subtree, returns the end node.\"\n  [zip-loc]\n  (if (zip/end? zip-loc)\n    zip-loc\n    (clojure.core/or (zip/right zip-loc)\n                     (loop [curr-loc zip-loc]\n                       (if (zip/up curr-loc)\n                         (clojure.core/or (zip/right (zip/up curr-loc))\n                                          (recur (zip/up curr-loc)))\n                         [(zip/node curr-loc) :end])))))\n\n;;\n;; Select\n;;\n\n(defn select-next-loc\n  \"Given a selector function and a loc inside a hickory zip data structure,\n   returns the next zipper loc that satisfies the selection function. This can\n   be the loc that is passed in, so be sure to move to the next loc if you\n   want to use this function to exhaustively search through a tree manually.\n   Note that if there is no next node that satisfies the selection function, nil\n   is returned.\n\n   The third argument, if present, must be a function of one argument that is\n   called on a zipper loc to return the next loc to consider in the search. By\n   default, this argument is zip/next. The fourth argument, if present, must be\n   a function of one argument that is called on a zipper loc to determine if\n   the end of the search has been reached (true return value). When the fourth\n   argument returns true on a loc, that loc is not considered in the search and\n   the search finishes with a nil return. By default, the fourth argument is\n   zip/end?.\"\n  ([selector-fn hzip-loc]\n     (select-next-loc selector-fn hzip-loc zip/next))\n  ([selector-fn hzip-loc next-fn]\n     (select-next-loc selector-fn hzip-loc next-fn zip/end?))\n  ([selector-fn hzip-loc next-fn end?-fn]\n     (loop [loc hzip-loc]\n       (if (end?-fn loc)\n         nil\n         (if (selector-fn loc)\n           loc\n           (recur (next-fn loc)))))))\n\n(defn select-locs\n  \"Given a selector function and a hickory data structure, returns a vector\n   containing all of the zipper locs selected by the selector function.\"\n  [selector-fn hickory-tree]\n  (loop [loc (select-next-loc selector-fn\n                              (hzip/hickory-zip hickory-tree))\n         selected-nodes (transient [])]\n    (if (nil? loc)\n      (persistent! selected-nodes)\n      (recur (select-next-loc selector-fn (zip/next loc))\n             (conj! selected-nodes loc)))))\n\n(defn select\n  \"Given a selector function and a hickory data structure, returns a vector\n   containing all of the hickory nodes selected by the selector function.\"\n  [selector-fn hickory-tree]\n  (mapv zip/node (select-locs selector-fn hickory-tree)))\n\n;;\n;; Selectors\n;;\n;; Mostly based off the spec at http://www.w3.org/TR/selectors/#selectors\n;; Some selectors are simply not possible outside a browser (active,\n;; visited, etc).\n;;\n\n(defn node-type\n  \"Return a function that takes a zip-loc argument and returns the\n   zip-loc passed in iff it has the given node type. The type\n   argument can be a String or Named (keyword, symbol). The node type\n   comparison is done case-insensitively.\"\n  [type]\n  (fn [hzip-loc]\n    (let [node (zip/node hzip-loc)\n          node-type (-> node :type)]\n      (if (clojure.core/and node-type\n                            (= (string/lower-case (name node-type))\n                               (string/lower-case (name type))))\n        hzip-loc))))\n\n(defn tag\n  \"Return a function that takes a zip-loc argument and returns the\n   zip-loc passed in iff it has the given tag. The tag argument can be\n   a String or Named (keyword, symbol). The tag name comparison\n   is done case-insensitively.\"\n  [tag]\n  (fn [hzip-loc]\n    (let [node (zip/node hzip-loc)\n          node-tag (-> node :tag)]\n      (if (clojure.core/and node-tag\n                            (= (string/lower-case (name node-tag))\n                               (string/lower-case (name tag))))\n        hzip-loc))))\n\n(defn attr\n  \"Returns a function that takes a zip-loc argument and returns the\n   zip-loc passed in iff it has the given attribute, and that attribute\n   optionally satisfies a predicate given as an additional argument. With\n   a single argument, the attribute name (a string, keyword, or symbol),\n   the function returned will return the zip-loc if that attribute is\n   present (and has any value) on the zip-loc's node. The attribute name\n   will be compared case-insensitively, but the attribute value (if present),\n   will be passed as-is to the predicate.\n\n   If the predicate argument is given, it will only return the zip-loc if\n   that predicate is satisfied when given the attribute's value as its only\n   argument. Note that the predicate only gets called when the attribute is\n   present, so it can assume its argument is not nil.\"\n  ([attr-name]\n     ;; Since we want this call to succeed in any case where this attr\n     ;; is present, we pass in a function that always returns true.\n     (attr attr-name (fn [_] true)))\n  ([attr-name predicate]\n     ;; Note that attribute names are normalized to lowercase by\n     ;; jsoup, as an html5 parser should; see here:\n     ;; http://www.whatwg.org/specs/web-apps/current-work/#attribute-name-state\n     (fn [hzip-loc]\n       (let [node (zip/node hzip-loc)\n             attr-key (keyword (string/lower-case (name attr-name)))]\n         ;; If the attribute does not exist, we'll definitely return null.\n         ;; Otherwise, we'll ask the predicate if we should return hzip-loc.\n         (if (clojure.core/and (contains? (:attrs node) attr-key)\n                               (predicate (get-in node [:attrs attr-key])))\n           hzip-loc)))))\n\n(defn id\n  \"Returns a function that takes a zip-loc argument and returns the\n   zip-loc passed in iff it has the given id. The id argument can be\n   a String or Named (keyword, symbol). The id name comparison\n   is done case-insensitively.\"\n  [id]\n  (attr :id #(= (string/lower-case %)\n                (string/lower-case (name id)))))\n\n(defn class\n  \"Returns a function that takes a zip-loc argument and returns the\n   zip-loc passed in iff it has the given class. The class argument can\n   be a String or Named (keyword, symbol). The class name comparison\n   is done case-insensitively.\"\n  [class-name]\n  (letfn [(parse-classes [class-str]\n                       (into #{} (mapv string/lower-case\n                                       (string/split class-str #\" \"))))]\n    (attr :class #(contains? (parse-classes %)\n                             (string/lower-case (name class-name))))))\n\n(defn any\n  \"This selector takes no args, it simply is the selector function. It returns\n   true on any element it is called on; corresponds to the CSS '*' selector.\"\n  [hzip-loc]\n  (if (= :element (-> (zip/node hzip-loc) :type))\n    hzip-loc))\n\n(def element\n  \"Another name for the any selector, to express that it can be used to only\n   select elements.\"\n  any)\n\n(defn element-child\n  \"This selector takes no args, it simply is the selector function. It returns\n   the zip-loc passed in iff that loc is an element, and it has a parent\n   that is also an element.\"\n  [hzip-loc]\n  (let [possible-parent (zip/up hzip-loc)]\n    (clojure.core/and (element hzip-loc)\n                      ;; Check that we are not at the top already first.\n                      possible-parent\n                      (element possible-parent))))\n\n(defn root\n  \"This selector takes no args, it simply is the selector function. It returns\n   the zip-loc of the root node (the HTML element).\"\n  [hzip-loc]\n  (if (= :html (-> (zip/node hzip-loc) :tag))\n    hzip-loc))\n\n(defn find-in-text\n  \"Returns a function that takes a zip-loc argument and returns the zip-loc\n   passed in iff it has some text node in its contents that matches the regular\n   expression. Note that this only applies to the direct text content of a node;\n   nodes which have the given text in one of their child nodes will not be\n   selected.\"\n  [re]\n  (fn [hzip-loc]\n    (some #(re-find re %) (->> (zip/node hzip-loc)\n                               :content\n                               (filter string?)))))\n\n(defn n-moves-until\n  \"This selector returns a selector function that selects its argument if\n   that argument is some \\\"distance\\\" from a \\\"boundary.\\\" This is an abstract\n   way of phrasing it, but it captures the full generality.\n\n   The selector this function returns will apply the move argument to its own\n   output, beginning with its zipper loc argument, until the term-pred argument\n   called on its output returns true. At that point, the number of times the\n   move function was called successfully is compared to kn+c; if there exists\n   some value of k such that the two quantities are equal, then the selector\n   will return the argument zipper loc successfully.\n\n   For example, (n-moves-until 2 1 clojure.zip/left nil?) will return a selector\n   that calls zip/left on its own output, beginning with the argument zipper\n   loc, until its return value is nil (nil? returns true). Suppose it called\n   left 5 times before zip/left returned nil. Then the selector will return\n   with success, since 2k+1 = 5 for k = 2.\n\n   Most nth-child-* selectors in this package use n-moves-until in their\n   implementation.\"\n  [n c move term-pred]\n  (fn [hzip-loc]\n    (let [distance (count-until move hzip-loc term-pred)]\n      (if (== 0 n)\n        ;; No stride, so distance must = c to select.\n        (if (== distance c)\n          hzip-loc)\n        ;; There's a stride, so need to subtract c and see if the\n        ;; remaining distance is a multiple of n.\n        (if (== 0 (rem (- distance c) n))\n          hzip-loc)))))\n\n(defn nth-of-type\n  \"Returns a function that returns true if the node is the nth child of\n   its parent (and it has a parent) of the given tag type. First element is 1,\n   last is n.\"\n  ([c typ]\n     (cond (= :odd c)\n           (nth-of-type 2 1 typ)\n           (= :even c)\n           (nth-of-type 2 0 typ)\n           :else\n           (nth-of-type 0 c typ)))\n  ([n c typ]\n     (fn [hzip-loc]\n       ;; We're only interested in elements whose parents are also elements,\n       ;; so check this up front and maybe save some work.\n       (if (clojure.core/and (element-child hzip-loc)\n                             (= typ (:tag (zip/node hzip-loc))))\n         (let [sel (n-moves-until n c\n                                  #(left-pred % (fn [x] (-> (zip/node x)\n                                                            :tag\n                                                            (= typ))))\n                                  nil?)]\n           (sel hzip-loc))))))\n\n(defn nth-last-of-type\n  \"Returns a function that returns true if the node is the nth last child of\n   its parent (and it has a parent) of the given tag type. First element is 1,\n   last is n.\"\n  ([c typ]\n     (cond (= :odd c)\n           (nth-last-of-type 2 1 typ)\n           (= :even c)\n           (nth-last-of-type 2 0 typ)\n           :else\n           (nth-last-of-type 0 c typ)))\n  ([n c typ]\n     (fn [hzip-loc]\n       ;; We're only interested in elements whose parents are also elements,\n       ;; so check this up front and maybe save some work.\n       (if (clojure.core/and (element-child hzip-loc)\n                             (= typ (:tag (zip/node hzip-loc))))\n         (let [sel (n-moves-until n c\n                                  #(right-pred % (fn [x] (-> (zip/node x)\n                                                             :tag\n                                                             (= typ))))\n                                  nil?)]\n           (sel hzip-loc))))))\n\n(defn nth-child\n  \"Returns a function that returns true if the node is the nth child of\n   its parent (and it has a parent). First element is 1, last is n.\"\n  ([c]\n     (cond (= :odd c)\n           (nth-child 2 1)\n           (= :even c)\n           (nth-child 2 0)\n           :else\n           (nth-child 0 c)))\n  ([n c]\n     (fn [hzip-loc]\n       ;; We're only interested in elements whose parents are also elements,\n       ;; so check this up front and maybe save some work.\n       (if (element-child hzip-loc)\n         (let [sel (n-moves-until n c #(left-of-node-type % :element) nil?)]\n           (sel hzip-loc))))))\n\n\n(defn nth-last-child\n  \"Returns a function that returns true if the node has n siblings after it,\n   and has a parent.\"\n  ([c]\n     (cond (= :odd c)\n           (nth-last-child 2 1)\n           (= :even c)\n           (nth-last-child 2 0)\n           :else\n           (nth-last-child 0 c)))\n  ([n c]\n     (fn [hzip-loc]\n       ;; We're only interested in elements whose parents are also elements,\n       ;; so check this up front and maybe save some work.\n       (if (element-child hzip-loc)\n         (let [sel (n-moves-until n c #(right-of-node-type % :element) nil?)]\n           (sel hzip-loc))))))\n\n(defn first-child\n  \"This selector takes no args, it is simply the selector. Returns\n   true if the node is the first child of its parent (and it has a\n   parent).\"\n  [hzip-loc]\n  (clojure.core/and (element-child hzip-loc)\n                    ((nth-child 1) hzip-loc)))\n\n(defn last-child\n  \"This selector takes no args, it is simply the selector. Returns\n   true if the node is the last child of its parent (and it has a\n   parent.\"\n  [hzip-loc]\n  (clojure.core/and (element-child hzip-loc)\n                    ((nth-last-child 1) hzip-loc)))\n\n;;\n;; Selector combinators\n;;\n\n(defn and\n  \"Takes any number of selectors and returns a selector that is true if\n   all of the argument selectors are true.\"\n  [& selectors]\n  (fn [zip-loc]\n    (if (every? #(% zip-loc) selectors)\n      zip-loc)))\n\n(defn or\n  \"Takes any number of selectors and returns a selector that is true if\n   any of the argument selectors are true.\"\n  [& selectors]\n  (fn [zip-loc]\n    (if (some #(% zip-loc) selectors)\n      zip-loc)))\n\n(defn not\n  \"Takes a selector argument and returns a selector that is true if\n   the underlying selector is false on its argument, and vice versa.\"\n  [selector]\n  (fn [hzip-loc]\n    (if (clojure.core/not (selector hzip-loc))\n      hzip-loc)))\n\n(defn el-not\n  \"Takes a selector argument and returns a selector that is true if\n   the underlying selector is false on its argument and vice versa, and\n   additionally that argument is an element node. Compared to the 'not'\n   selector, this corresponds more closely to the CSS equivalent, which\n   will only ever select elements.\"\n  [selector]\n  (and (node-type :element)\n       (not selector)))\n\n(defn ordered-adjacent\n  \"Takes a zipper movement function and any number of selectors as arguments\n   and returns a selector that returns true when the zip-loc given as the\n   argument is satisfied by the first selector, and the zip-loc arrived at by\n   applying the move-fn argument is satisfied by the second selector, and so\n   on for all the selectors given as arguments. If the move-fn\n   moves to nil before the full selector list is satisfied, the entire\n   selector fails, but note that success is checked before a move to nil is\n   checked, so satisfying the last selector with the last node you can move\n   to succeeds.\"\n  [move-fn & selectors]\n  ;; We'll work backwards through the selector list with an index. First we'll\n  ;; build the selector list into an array for quicker access. We'll do it\n  ;; immediately and then closure-capture the result, so it does not get\n  ;; redone every time the selector is called.\n  (let [selectors (into-array IFn selectors)]\n    (fn [hzip-loc]\n      (loop [curr-loc hzip-loc\n             idx 0]\n        (cond (>= idx (count selectors))\n              hzip-loc ;; Got to end satisfying selectors, return the loc.\n              (nil? curr-loc)\n              nil ;; Ran off a boundary before satisfying selectors, return nil.\n              :else\n              (if-let [next-loc ((nth selectors idx) curr-loc)]\n                (recur (move-fn next-loc)\n                       (inc idx))))))))\n\n(defn child\n  \"Takes any number of selectors as arguments and returns a selector that\n   returns true when the zip-loc given as the argument is at the end of\n   a chain of direct child relationships specified by the selectors given as\n   arguments.\n\n   Example: (child (tag :div) (class :foo) (attr :disabled))\n     will select the input in\n   <div><span class=\\\"foo\\\"><input disabled></input></span></div>\n     but not in\n   <div><span class=\\\"foo\\\"><b><input disabled></input></b></span></div>\"\n  [& selectors]\n  (apply ordered-adjacent zip/up (reverse selectors)))\n\n(defn follow-adjacent\n  \"Takes any number of selectors as arguments and returns a selector that\n   returns true when the zip-loc given as the argument is at the end of\n   a chain of direct element sibling relationships specified by the selectors\n   given as arguments.\n\n   Example: (follow-adjacent (tag :div) (class :foo))\n     will select the span in\n   <div>...</div><span class=\\\"foo\\\">...</span>\n     but not in\n   <div>...</div><b>...</b><span class=\\\"foo\\\">...</span>\"\n  [& selectors]\n  (apply ordered-adjacent\n         #(left-of-node-type % :element)\n         (reverse selectors)))\n\n(defn precede-adjacent\n  \"Takes any number of selectors as arguments and returns a selector that\n   returns true when the zip-loc given as the argument is at the beginning of\n   a chain of direct element sibling relationships specified by the selectors\n   given as arguments.\n\n   Example: (precede-adjacent (tag :div) (class :foo))\n     will select the div in\n   <div>...</div><span class=\\\"foo\\\">...</span>\n     but not in\n   <div>...</div><b>...</b><span class=\\\"foo\\\">...</span>\"\n  [& selectors]\n  (apply ordered-adjacent\n         #(right-of-node-type % :element)\n         selectors))\n\n(defn ordered\n  \"Takes a zipper movement function and any number of selectors as arguments\n   and returns a selector that returns true when the zip-loc given as the\n   argument is satisfied by the first selector, and some zip-loc arrived at by\n   applying the move-fn argument *one or more times* is satisfied by the second\n   selector, and so on for all the selectors given as arguments. If the move-fn\n   moves to nil before a the full selector list is satisfied, the entire\n   selector fails, but note that success is checked before a move to nil is\n   checked, so satisfying the last selector with the last node you can move\n   to succeeds.\"\n  [move-fn & selectors]\n  ;; This function is a lot like ordered-adjacent, above, but:\n  ;; 1) failing to fulfill a selector does not stop us moving along the tree\n  ;; 2) therefore, we need to make sure the first selector matches the loc under\n  ;;    consideration, and not merely one that is farther along the movement\n  ;;    direction.\n  (let [selectors (into-array IFn selectors)]\n    (fn [hzip-loc]\n      ;; First need to check that the first selector matches the current loc,\n      ;; or else we can return nil immediately.\n      (let [fst-selector (nth selectors 0)]\n        (if (fst-selector hzip-loc)\n          ;; First selector matches this node, so now check along the\n          ;; movement direction for the rest of the selectors.\n          (loop [curr-loc (move-fn hzip-loc)\n                 idx 1]\n            (cond (>= idx (count selectors))\n                  hzip-loc ;; Satisfied all selectors, so return the orig. loc.\n                  (nil? curr-loc)\n                  nil ;; Ran out of movements before selectors, return nil.\n                  :else\n                  (if ((nth selectors idx) curr-loc)\n                    (recur (move-fn curr-loc)\n                           (inc idx))\n                    ;; Failed, so move but retry the same selector\n                    (recur (move-fn curr-loc) idx)))))))))\n\n(defn descendant\n  \"Takes any number of selectors as arguments and returns a selector that\n   returns true when the zip-loc given as the argument is at the end of\n   a chain of descendant relationships specified by the\n   selectors given as arguments. To be clear, the node selected matches\n   the final selector, but the previous selectors can match anywhere in\n   the node's ancestry, provided they match in the order they are given\n   as arguments, from top to bottom.\n\n   Example: (descendant (tag :div) (class :foo) (attr :disabled))\n     will select the input in both\n   <div><span class=\\\"foo\\\"><input disabled></input></span></div>\n     and\n   <div><span class=\\\"foo\\\"><b><input disabled></input></b></span></div>\"\n  [& selectors]\n  (apply ordered zip/up (reverse selectors)))\n\n(defn follow\n  \"Takes any number of selectors as arguments and returns a selector that\n   returns true when the zip-loc given as the argument is at the end of\n   a chain of element sibling relationships specified by the selectors\n   given as arguments; intervening elements that do not satisfy a selector\n   are simply ignored and do not prevent a match.\n\n   Example: (follow (tag :div) (class :foo))\n     will select the span in both\n   <div>...</div><span class=\\\"foo\\\">...</span>\n     and\n   <div>...</div><b>...</b><span class=\\\"foo\\\">...</span>\"\n  [& selectors]\n  (apply ordered #(left-of-node-type % :element) (reverse selectors)))\n\n(defn precede\n  \"Takes any number of selectors as arguments and returns a selector that\n   returns true when the zip-loc given as the argument is at the beginning of\n   a chain of element sibling relationships specified by the selectors\n   given as arguments; intervening elements that do not satisfy a selector\n   are simply ignored and do not prevent a match.\n\n   Example: (precede (tag :div) (class :foo))\n     will select the div in both\n   <div>...</div><span class=\\\"foo\\\">...</span>\n     and\n   <div>...</div><b>...</b><span class=\\\"foo\\\">...</span>\"\n  [& selectors]\n  (apply ordered #(right-of-node-type % :element) selectors))\n\n(defn has-descendant\n  \"Takes a selector as argument and returns a selector that returns true\n   when some descendant node of the zip-loc given as the argument satisfies\n   the selector.\n\n   Be aware that because this selector must do a full sub-tree search on\n   each node examined, it can have terrible performance. It's helpful if this is\n   a late clause in an `and`, to prevent it from even attempting to match\n   unless other criteria have been met first.\n\n   Example: (has-descendant (tag :div))\n     will select the span and the outer div, but not the inner div, in\n   <span><div><div></div></div></span>\"\n  [selector]\n  (fn [hzip-loc]\n    ;; Want to not count the current node, and stop after the last node\n    ;; in the subtree of it has been checked, which is the next node\n    ;; after the rightmost child.\n    (let [subtree-start-loc (-> hzip-loc zip/down)\n          has-children? (not= nil subtree-start-loc)]\n      ;; has-children? is needed to guard against zip/* receiving a nil arg in\n      ;; a selector.\n      (if has-children?\n        (let [subtree-end-loc (after-subtree hzip-loc)]\n          (if (select-next-loc selector subtree-start-loc\n                               zip/next\n                               #(= % subtree-end-loc))\n            hzip-loc))))))\n\n(defn has-child\n  \"Takes a selector as argument and returns a selector that returns true\n   when some direct child node of the zip-loc given as the argument satisfies\n   the selector.\n\n   Example: (has-child (tag :div))\n     will select only the inner span in\n   <div><span><div></div></span></div>\"\n  [selector]\n  (fn [hzip-loc]\n    (let [subtree-start-loc (-> hzip-loc zip/down)\n          has-children? (not= nil subtree-start-loc)]\n      ;; has-children? is needed to guard against zip/* receiving a nil arg in\n      ;; a selector.\n      (if has-children?\n        (if (select-next-loc selector subtree-start-loc\n                             zip/right\n                             #(nil? %))\n          hzip-loc)))))\n\n"]}